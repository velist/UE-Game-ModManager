# UEModManager 分类系统重构修改记录

**修改日期：** 2025-10-05
**修改版本：** v1.7.37
**修改范围：** 分类显示名称、软删除、数据持久化
**修改人员：** Claude Code (AI Assistant)

---

## 📋 目录

1. [修改背景](#修改背景)
2. [需求概述](#需求概述)
3. [技术方案](#技术方案)
4. [代码变更详情](#代码变更详情)
5. [问题与解决方案](#问题与解决方案)
6. [测试验证](#测试验证)
7. [注意事项](#注意事项)
8. [后续维护指南](#后续维护指南)

---

## 修改背景

### 原有问题
1. **分类重命名会影响MOD标签**：重命名分类会同步修改所有MOD的标签字段，导致数据一致性问题
2. **删除分类会丢失数据**：删除有MOD的分类会直接删除分类，MOD失去分类归属
3. **默认分类不可编辑**：面部、人物、武器等默认分类无法重命名或删除，限制用户自定义需求
4. **刷新后数据丢失**：MOD分类在刷新后会被重置为默认值

### 用户需求演进

**第一阶段：** 分离显示名称与标签名称
- 重命名分类只修改UI显示，不影响MOD标签
- 右键菜单显示 "标签名（显示名）" 格式

**第二阶段：** 实现软删除机制
- 删除分类改为隐藏，而非真删除
- 删除前自动将MOD移动到"未分类"
- 智能显示：当MOD使用隐藏分类时自动显示该分类

**第三阶段：** 修复持久化问题
- 默认分类（面部、人物、武器等）无法隐藏
- 新建分类可以隐藏，但默认分类会重新出现
- MOD分类在刷新后被重置

---

## 需求概述

### 核心功能需求

#### 1. 分类显示名称管理
- **需求描述**：允许用户自定义分类的显示名称，但不修改底层标签名
- **实现方式**：新增 `DisplayName` 属性，独立于 `Name`（标签名）
- **显示规则**：
  - 左侧分类列表显示 `DisplayName`（如果有）或 `Name`
  - 右侧MOD标签始终显示原始 `Name`
  - 右键移动分类菜单显示 "标签名（显示名）" 或 "标签名"

#### 2. 软删除机制
- **需求描述**：删除分类不实际删除，而是隐藏
- **实现方式**：新增 `IsHidden` 属性作为隐藏标记
- **删除流程**：
  1. 检查分类下是否有MOD
  2. 如有MOD，自动移动到"未分类"
  3. 设置 `IsHidden = true`
  4. 保存配置并刷新显示
- **智能显示**：当MOD使用隐藏分类时，自动显示该分类

#### 3. 配置持久化
- **需求描述**：分类配置（DisplayName、IsHidden）需要持久化存储
- **存储位置**：`%AppData%\UEModManager\{gamename}_category_display.json`
- **存储内容**：
```json
{
  "面部": {
    "DisplayName": "面部MOD",
    "IsHidden": false
  },
  "武器": {
    "DisplayName": null,
    "IsHidden": true
  }
}
```

#### 4. 数据同步
- **需求描述**：刷新操作不应丢失用户自定义的分类配置
- **实现方式**：从配置文件加载，而非从内存集合

---

## 技术方案

### 架构设计

#### 数据模型层
```csharp
public class Category : INotifyPropertyChanged
{
    // 不可变标签名（用于MOD关联）
    public string Name { get; set; }

    // 可变显示名（用于UI显示）
    public string? DisplayName { get; set; }

    // 软删除标记
    public bool IsHidden { get; set; }

    // 计算属性（用于绑定）
    public string DisplayText => DisplayName ?? Name;

    // MOD数量
    public int Count { get; set; }
}
```

#### 配置模型层
```csharp
public class CategoryDisplayConfig
{
    public string? DisplayName { get; set; }
    public bool IsHidden { get; set; }
}
```

#### 数据流图
```
用户操作 (重命名/删除)
    ↓
更新 Category 对象 (DisplayName/IsHidden)
    ↓
SaveCategoryDisplayConfig() - 保存到配置文件
    ↓
RefreshCategoryDisplay() - 刷新UI
    ↓
从配置文件加载 DisplayName 和 IsHidden
    ↓
过滤 IsHidden = true 的分类
    ↓
更新 ObservableCollection<Category>
    ↓
UI 自动刷新（数据绑定）
```

### 关键技术点

#### 1. 配置合并策略
**问题**：`categories` 集合只包含可见分类，直接保存会丢失已隐藏分类的配置

**解决方案**：保存时先加载现有配置，再合并更新
```csharp
// 步骤1：加载现有配置
var config = LoadExistingConfig() ?? new Dictionary<...>();

// 步骤2：更新/添加当前可见分类
foreach (var cat in categories) {
    config[cat.Name] = new CategoryDisplayConfig { ... };
}

// 步骤3：保存合并后的配置
SaveConfig(config);
```

#### 2. 从配置文件加载状态
**问题**：`RefreshCategoryDisplay()` 从内存集合加载配置，导致隐藏状态丢失

**解决方案**：直接从配置文件加载
```csharp
// 从文件加载配置
var savedConfig = LoadConfigFromFile();

// 应用到新分类
foreach (var cat in newCategories) {
    if (savedConfig.TryGetValue(cat.Name, out var config)) {
        cat.DisplayName = config.DisplayName;
        cat.IsHidden = config.IsHidden;
    }
}
```

#### 3. 避免重复初始化
**问题**：`InitializeDefaultCategories()` 在刷新后重新添加默认分类，覆盖 `IsHidden` 状态

**解决方案**：移除 `RefreshCategoryDisplay()` 中的 `InitializeDefaultCategories()` 调用，默认分类已在前面逻辑中处理

#### 4. 统一数据恢复逻辑
**问题**：`RefreshButton_Click()` 有三次数据恢复，且查询逻辑不一致，导致数据丢失

**解决方案**：移除冗余的第三次恢复，依赖 `InitializeModsForGame()` 的统一恢复逻辑

---

## 代码变更详情

### 文件清单
1. `D:\cursor\2.0backup\backup_v1.7.32\UEModManager\MainWindow.xaml` - UI绑定修改
2. `D:\cursor\2.0backup\backup_v1.7.32\UEModManager\MainWindow.xaml.cs` - 业务逻辑修改

---

### 变更1: UI绑定修改

**文件**：`MainWindow.xaml`
**位置**：第 168 行

#### 修改前
```xml
<TextBlock Name="CategoryName" Grid.Column="0" Text="{Binding Name}"
           FontSize="14" Foreground="White" VerticalAlignment="Center"
           Margin="5,0,0,0"/>
```

#### 修改后
```xml
<TextBlock Name="CategoryName" Grid.Column="0" Text="{Binding DisplayText}"
           FontSize="14" Foreground="White" VerticalAlignment="Center"
           Margin="5,0,0,0"/>
```

#### 说明
- 绑定从 `Name` 改为 `DisplayText`
- `DisplayText` 是计算属性：`DisplayName ?? Name`
- 当有自定义显示名称时显示 `DisplayName`，否则显示原始 `Name`

---

### 变更2: Category 数据模型扩展

**文件**：`MainWindow.xaml.cs`
**位置**：第 10623-10691 行

#### 新增代码
```csharp
public class Category : INotifyPropertyChanged
{
    private string _name = "";
    public string Name
    {
        get => _name;
        set
        {
            if (_name != value)
            {
                _name = value;
                OnPropertyChanged(nameof(Name));
                OnPropertyChanged(nameof(DisplayText));
            }
        }
    }

    private string? _displayName;
    public string? DisplayName
    {
        get => _displayName;
        set
        {
            if (_displayName != value)
            {
                _displayName = value;
                OnPropertyChanged(nameof(DisplayName));
                OnPropertyChanged(nameof(DisplayText));
            }
        }
    }

    private bool _isHidden;
    public bool IsHidden
    {
        get => _isHidden;
        set
        {
            if (_isHidden != value)
            {
                _isHidden = value;
                OnPropertyChanged(nameof(IsHidden));
            }
        }
    }

    // 计算属性：优先显示DisplayName，否则显示Name
    public string DisplayText => DisplayName ?? Name;

    private int _count;
    public int Count
    {
        get => _count;
        set
        {
            if (_count != value)
            {
                _count = value;
                OnPropertyChanged(nameof(Count));
            }
        }
    }

    public event PropertyChangedEventHandler? PropertyChanged;

    protected virtual void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
```

#### 说明
- **Name**：不可变标签名，用于MOD关联（`mod.Type`、`mod.Categories`）
- **DisplayName**：可变显示名，仅用于UI展示
- **IsHidden**：软删除标记，`true` 表示已隐藏
- **DisplayText**：计算属性，数据绑定使用
- **INotifyPropertyChanged**：支持WPF数据绑定自动更新

---

### 变更3: CategoryDisplayConfig 配置模型

**文件**：`MainWindow.xaml.cs`
**位置**：第 10693-10697 行

#### 新增代码
```csharp
public class CategoryDisplayConfig
{
    public string? DisplayName { get; set; }
    public bool IsHidden { get; set; }
}
```

#### 说明
- 用于 JSON 序列化/反序列化
- 对应配置文件中每个分类的配置项

---

### 变更4: GetCategoryDisplayConfigPath 方法

**文件**：`MainWindow.xaml.cs`
**位置**：第 10582-10590 行

#### 新增代码
```csharp
private string GetCategoryDisplayConfigPath()
{
    var appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
    var modManagerPath = Path.Combine(appDataPath, "UEModManager");
    Directory.CreateDirectory(modManagerPath);

    var configFileName = $"{_currentGame}_category_display.json";
    return Path.Combine(modManagerPath, configFileName);
}
```

#### 说明
- 每个游戏独立的配置文件
- 存储在 `%AppData%\UEModManager\`
- 文件名格式：`{游戏名}_category_display.json`

---

### 变更5: SaveCategoryDisplayConfig 方法（配置合并策略）

**文件**：`MainWindow.xaml.cs`
**位置**：第 10514-10575 行

#### 完整代码
```csharp
private void SaveCategoryDisplayConfig()
{
    try
    {
        if (categories == null || categories.Count == 0)
        {
            Console.WriteLine("[保存] categories 为空，跳过保存");
            return;
        }

        // 方案A：先加载现有配置，然后合并更新，避免丢失已隐藏分类的配置
        var config = new Dictionary<string, CategoryDisplayConfig>();

        // 步骤1：加载现有配置文件
        var configPath = GetCategoryDisplayConfigPath();
        if (File.Exists(configPath))
        {
            try
            {
                var existingJson = File.ReadAllText(configPath, System.Text.Encoding.UTF8);
                var existingConfig = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, CategoryDisplayConfig>>(existingJson);
                if (existingConfig != null)
                {
                    config = existingConfig;
                    Console.WriteLine($"[保存] 加载现有配置: {config.Count} 个分类");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[警告] 加载现有配置失败，将使用新配置: {ex.Message}");
            }
        }

        // 步骤2：更新/添加当前可见分类的配置
        foreach (var cat in categories)
        {
            // 只保存有自定义配置的分类（有DisplayName或IsHidden的）
            if (!string.IsNullOrEmpty(cat.DisplayName) || cat.IsHidden)
            {
                config[cat.Name] = new CategoryDisplayConfig
                {
                    DisplayName = cat.DisplayName,
                    IsHidden = cat.IsHidden
                };
                Console.WriteLine($"[保存] 更新分类 '{cat.Name}': DisplayName={cat.DisplayName}, IsHidden={cat.IsHidden}");
            }
            else
            {
                // 如果没有自定义配置，从配置中移除（使用默认值）
                config.Remove(cat.Name);
                Console.WriteLine($"[保存] 移除分类 '{cat.Name}' 的配置（使用默认）");
            }
        }

        // 步骤3：保存合并后的配置
        var options = new System.Text.Json.JsonSerializerOptions
        {
            WriteIndented = true,
            Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping
        };
        var json = System.Text.Json.JsonSerializer.Serialize(config, options);
        File.WriteAllText(configPath, json, System.Text.Encoding.UTF8);

        Console.WriteLine($"[保存] 分类显示配置已保存到: {configPath}");
        Console.WriteLine($"[保存] 共保存 {config.Count} 个分类配置（含已隐藏分类）");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"[错误] 保存分类显示配置失败: {ex.Message}");
    }
}
```

#### 关键逻辑
1. **加载现有配置**：避免丢失已隐藏分类的配置
2. **合并更新**：更新当前可见分类的配置
3. **选择性保存**：只保存有自定义配置的分类（有 `DisplayName` 或 `IsHidden`）
4. **UTF8编码**：支持中文字符

#### 为什么需要配置合并？
- `categories` 集合在 `RefreshCategoryDisplay()` 中已经过滤掉 `IsHidden = true` 的分类
- 如果直接保存 `categories`，会丢失已隐藏分类的配置
- 必须先加载现有配置，再合并更新

---

### 变更6: RefreshCategoryDisplay 方法（从文件加载配置）

**文件**：`MainWindow.xaml.cs`
**位置**：第 8071-8196 行

#### 关键修改点1：从配置文件加载（第 8108-8142 行）

```csharp
// 加载显示配置（DisplayName和IsHidden）- 从配置文件加载而非从categories集合
var categoriesWithConfig = new List<Category>();

// ✅ 关键修改：从配置文件加载所有配置（包括已隐藏的分类配置）
Dictionary<string, CategoryDisplayConfig>? savedConfig = null;
try
{
    var configPath = GetCategoryDisplayConfigPath();
    if (File.Exists(configPath))
    {
        var configJson = File.ReadAllText(configPath, System.Text.Encoding.UTF8);
        savedConfig = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, CategoryDisplayConfig>>(configJson);
        if (savedConfig != null)
        {
            Console.WriteLine($"[刷新] 从配置文件加载: {savedConfig.Count} 个分类配置");
        }
    }
}
catch (Exception ex)
{
    Console.WriteLine($"[警告] 加载分类配置失败: {ex.Message}");
}

foreach (var cat in newCategories)
{
    // ✅ 从配置文件应用DisplayName和IsHidden
    if (savedConfig != null && savedConfig.TryGetValue(cat.Name, out var config))
    {
        cat.DisplayName = config.DisplayName;
        cat.IsHidden = config.IsHidden;
        Console.WriteLine($"[刷新] 应用配置到分类 '{cat.Name}': DisplayName={config.DisplayName}, IsHidden={config.IsHidden}");
    }

    categoriesWithConfig.Add(cat);
}
```

#### 说明
- **修改前**：从 `categories` 集合中查找已存在的分类，复制其 `DisplayName` 和 `IsHidden`
- **修改后**：直接从配置文件加载
- **为什么修改**：`categories` 集合已过滤掉隐藏分类，从中加载会丢失隐藏状态

#### 关键修改点2：移除 InitializeDefaultCategories 调用（第 8187-8196 行）

```csharp
Dispatcher.Invoke(() =>
{
    categories.Clear();
    foreach (var cat in visibleCategories)
    {
        categories.Add(cat);
    }

    // ✅ 已删除 InitializeDefaultCategories() 调用
    // 默认分类已在上面的逻辑中正确处理（包括从配置文件加载的 IsHidden 状态）
    // 不再需要重新初始化，避免覆盖 IsHidden 状态

    // 恢复之前选中的分类
    if (!string.IsNullOrEmpty(previousSelectedCategory))
    {
        var categoryToSelect = categories.FirstOrDefault(c => c.Name == previousSelectedCategory);
        if (categoryToSelect != null)
        {
            CategoryListBox.SelectedItem = categoryToSelect;
        }
    }
});
```

#### 说明
- **修改前**：调用 `InitializeDefaultCategories()` 重新添加默认分类
- **修改后**：删除该调用
- **为什么修改**：`InitializeDefaultCategories()` 会重新添加默认分类（面部、人物、武器等）且 `IsHidden` 默认为 `false`，覆盖了从配置文件加载的隐藏状态

---

### 变更7: RenameCategoryButton_Click 方法（重命名分类）

**文件**：`MainWindow.xaml.cs`
**位置**：第 9670-9730 行

#### 完整代码
```csharp
private void RenameCategoryButton_Click(object sender, RoutedEventArgs e)
{
    if (CategoryListBox.SelectedItem is Category selectedCategory)
    {
        // 获取当前的显示名称（如果没有DisplayName则显示Name）
        string currentDisplayName = selectedCategory.DisplayText;

        // 弹出输入对话框
        string newDisplayName = ShowInputDialog(
            "设置分类显示名称（仅修改显示，不影响标签）:",
            "重命名分类",
            currentDisplayName
        );

        if (string.IsNullOrWhiteSpace(newDisplayName))
        {
            // 用户取消或输入为空
            return;
        }

        // 如果新名称等于标签名，清空DisplayName（恢复默认）
        if (newDisplayName.Equals(selectedCategory.Name, StringComparison.OrdinalIgnoreCase))
        {
            selectedCategory.DisplayName = null;
            Console.WriteLine($"[重命名] 清空分类 '{selectedCategory.Name}' 的显示名称，恢复默认");
        }
        else
        {
            selectedCategory.DisplayName = newDisplayName;
            Console.WriteLine($"[重命名] 设置分类 '{selectedCategory.Name}' 的显示名称为 '{newDisplayName}'");
        }

        // 保存配置
        SaveCategoryDisplayConfig();

        // 刷新分类显示
        RefreshCategoryDisplay();

        // 显示成功消息
        ShowCustomMessageBox(
            $"分类显示名称已更新\n\n标签名（用于MOD关联）：{selectedCategory.Name}\n显示名（仅UI显示）：{selectedCategory.DisplayText}\n\n注意：MOD区的标签名称不变，仍为 '{selectedCategory.Name}'",
            "重命名成功",
            MessageBoxButton.OK,
            MessageBoxImage.Information
        );
    }
}
```

#### 说明
- **只修改 DisplayName**：不修改 `Name`（标签名）
- **恢复默认**：如果输入名称等于标签名，清空 `DisplayName`
- **不影响MOD**：MOD的 `Type` 和 `Categories` 字段保持不变
- **提示信息**：明确告知用户标签名不变

---

### 变更8: DeleteCategoryButton_Click 方法（软删除分类）

**文件**：`MainWindow.xaml.cs`
**位置**：第 8255-8382 行

#### 完整代码
```csharp
private async void DeleteCategoryButton_Click(object sender, RoutedEventArgs e)
{
    if (CategoryListBox.SelectedItems.Count == 0)
    {
        ShowCustomMessageBox("请先选择要删除的分类", "提示", MessageBoxButton.OK, MessageBoxImage.Information);
        return;
    }

    // 获取所选分类
    var categoriesToHide = CategoryListBox.SelectedItems.Cast<Category>().ToList();

    // 检查是否有MOD使用这些分类
    var allMods = GetAllModsForCurrentGame();
    int affectedModCount = 0;
    foreach (var category in categoriesToHide)
    {
        var modsInCategory = allMods.Where(mod =>
            mod.Type == category.Name ||
            (mod.Categories != null && mod.Categories.Contains(category.Name))
        ).ToList();

        affectedModCount += modsInCategory.Count;
    }

    // 构建确认消息
    string confirmMessage;
    if (affectedModCount > 0)
    {
        confirmMessage = $"确定要删除选中的 {categoriesToHide.Count} 个分类吗？\n\n";
        confirmMessage += $"这些分类下有 {affectedModCount} 个MOD，将自动移动到"未分类"。\n\n";
        confirmMessage += "分类将被隐藏（不会真删除），如果MOD重新使用该分类，它会再次显示。";
    }
    else
    {
        confirmMessage = $"确定要删除选中的 {categoriesToHide.Count} 个分类吗？\n\n";
        confirmMessage += "分类将被隐藏（不会真删除），如果MOD重新使用该分类，它会再次显示。";
    }

    var result = ShowCustomMessageBox(
        confirmMessage,
        "确认删除",
        MessageBoxButton.YesNo,
        MessageBoxImage.Question
    );

    if (result == MessageBoxResult.Yes)
    {
        try
        {
            // 步骤1：将使用这些分类的 MOD 移动到"未分类"
            int movedModCount = 0;
            foreach (var category in categoriesToHide)
            {
                var affectedMods = allMods.Where(mod =>
                    mod.Type == category.Name ||
                    (mod.Categories != null && mod.Categories.Contains(category.Name))
                ).ToList();

                if (affectedMods.Any())
                {
                    Console.WriteLine($"[删除] 分类 '{category.Name}' 下有 {affectedMods.Count} 个MOD，将移动到"未分类"");

                    foreach (var mod in affectedMods)
                    {
                        // 更新 Type 字段
                        if (mod.Type == category.Name)
                        {
                            mod.Type = "未分类";
                            Console.WriteLine($"[删除] MOD '{mod.Name}' 的 Type 从 '{category.Name}' 改为 '未分类'");
                        }

                        // 更新 Categories 字段
                        if (mod.Categories != null && mod.Categories.Contains(category.Name))
                        {
                            // 移除当前分类
                            mod.Categories = mod.Categories
                                .Where(c => c != category.Name)
                                .ToList();

                            // 如果移除后为空，添加"未分类"
                            if (!mod.Categories.Any())
                            {
                                mod.Categories.Add("未分类");
                            }

                            Console.WriteLine($"[删除] MOD '{mod.Name}' 的 Categories 已更新: {string.Join(", ", mod.Categories)}");
                        }

                        // 通知属性变更（触发UI更新）
                        mod.OnPropertyChanged(nameof(mod.Type));
                        mod.OnPropertyChanged(nameof(mod.Categories));
                        movedModCount++;
                    }
                }
            }

            // 步骤2：保存 MOD 数据到配置文件
            if (movedModCount > 0)
            {
                Console.WriteLine($"[删除] 共移动 {movedModCount} 个MOD，保存到 ModService");
                await SaveModsToModServiceAsync();
            }

            // 步骤3：设置 IsHidden = true（软删除）
            foreach (var category in categoriesToHide)
            {
                category.IsHidden = true;
                Console.WriteLine($"[删除] 分类 '{category.Name}' 已设置为隐藏");
            }

            // 步骤4：保存分类显示配置
            SaveCategoryDisplayConfig();

            // 步骤5：刷新分类显示（会自动过滤掉IsHidden=true的分类）
            RefreshCategoryDisplay();

            // 步骤6：显示成功消息
            string successMessage = $"已删除 {categoriesToHide.Count} 个分类";
            if (movedModCount > 0)
            {
                successMessage += $"\n已将 {movedModCount} 个MOD移动到"未分类"";
            }
            ShowCustomMessageBox(successMessage, "删除成功", MessageBoxButton.OK, MessageBoxImage.Information);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[错误] 删除分类失败: {ex.Message}\n{ex.StackTrace}");
            ShowCustomMessageBox($"删除分类失败: {ex.Message}", "错误", MessageBoxButton.OK, MessageBoxImage.Error);
        }
    }
}
```

#### 删除流程
1. **检查MOD**：统计使用该分类的MOD数量
2. **确认对话框**：提示用户将有多少MOD被移动
3. **移动MOD**：将MOD的 `Type` 和 `Categories` 改为"未分类"
4. **保存MOD数据**：调用 `SaveModsToModServiceAsync()`
5. **设置隐藏**：`IsHidden = true`
6. **保存配置**：调用 `SaveCategoryDisplayConfig()`
7. **刷新UI**：调用 `RefreshCategoryDisplay()`

#### 智能显示逻辑
在 `RefreshCategoryDisplay()` 中实现：
```csharp
// 如果某个隐藏分类有MOD在使用，自动显示该分类
if (cat.IsHidden && cat.Count > 0)
{
    Console.WriteLine($"[智能显示] 分类 '{cat.Name}' 虽然已隐藏，但仍有 {cat.Count} 个MOD使用，自动显示");
    cat.IsHidden = false;  // 临时取消隐藏
}

// 过滤掉仍然IsHidden=true的分类
var visibleCategories = categoriesWithConfig.Where(c => !c.IsHidden).ToList();
```

---

### 变更9: MoveToCategorySubMenuItem 显示格式

**文件**：`MainWindow.xaml.cs`
**位置**：第 9081-9116 行

#### 关键代码
```csharp
foreach (var category in availableCategories)
{
    // 构建菜单显示文本：标签名（显示名）或 标签名
    string menuHeader;
    if (!string.IsNullOrEmpty(category.DisplayName))
    {
        menuHeader = $"{category.Name}（{category.DisplayName}）";
    }
    else
    {
        menuHeader = category.Name;
    }

    var categoryMenuItem = new MenuItem
    {
        Header = menuHeader,
        Style = (Style)FindResource("DarkMenuItem"),
        Tag = rightClickedMod
    };

    // 添加图标
    var icon = new Image
    {
        Source = new BitmapImage(new Uri("pack://application:,,,/tag_icon.png")),
        Width = 16,
        Height = 16
    };
    categoryMenuItem.Icon = icon;

    // 点击事件（使用原始Name，不是DisplayName）
    var categoryName = category.Name;
    categoryMenuItem.Click += (s, args) => MoveToCategorySubMenuItem_Click(s, args, categoryName);

    moveToCategoryMenuItem.Items.Add(categoryMenuItem);
}
```

#### 说明
- **显示格式**：有 `DisplayName` 时显示 "标签名（显示名）"，否则只显示 "标签名"
- **逻辑使用 Name**：移动MOD时使用原始 `Name`，确保数据一致性

---

### 变更10: RefreshButton_Click 移除冗余恢复逻辑

**文件**：`MainWindow.xaml.cs`
**位置**：第 4519-4525 行

#### 修改前（已删除的代码）
```csharp
// 从ModService恢复自定义名称、描述、分类等
if (_modService != null)
{
    Console.WriteLine("[DEBUG] 从ModService恢复自定义名称和描述");

    foreach (var mod in allMods)
    {
        // ❌ 问题：缺少 m.DisplayName == mod.Name 条件
        var modInfo = _modService.Mods.FirstOrDefault(m =>
            m.Name == mod.RealName ||
            (!string.IsNullOrEmpty(m.PreviewImagePath) &&
             !string.IsNullOrEmpty(mod.PreviewImagePath) &&
             TryCompareImagePaths(m.PreviewImagePath, mod.PreviewImagePath)));

        if (modInfo != null)
        {
            // ... 其他字段恢复 ...

            // ❌ 如果找不到modInfo，使用默认值覆盖用户分类
            mod.Categories = modInfo.Categories?.ToList() ?? new List<string> { "未分类" };
        }
    }
}
```

#### 修改后（第 4519-4525 行）
```csharp
// ✅ 已移除冗余的第三次数据恢复逻辑
// InitializeModsForGame() 方法内部已经从 ModService 恢复了所有数据（DisplayName、Description、Categories 等）
// 不需要在这里重复恢复，避免因查找逻辑不一致导致数据丢失
//
// 修复 BUG: 之前这里的查找逻辑缺少 m.DisplayName == mod.Name 条件，
// 导致找不到 modInfo 时使用默认值 new List<string> { "未分类" } 覆盖了用户自定义的分类
Console.WriteLine("[DEBUG] MOD数据已在 InitializeModsForGame 中从 ModService 完整恢复，跳过冗余恢复");
```

#### 说明
- **问题根源**：
  1. 保存时的查询条件：`m.Name == mod.RealName || m.DisplayName == mod.Name || 图片对比`
  2. 恢复时的查询条件：`m.Name == mod.RealName || 图片对比`（缺少 `DisplayName` 条件）
  3. 查询不一致导致找不到 `modInfo`，使用默认值 `new List<string> { "未分类" }` 覆盖用户分类

- **解决方案**：
  - `InitializeModsForGame()` 内部已经正确恢复所有数据
  - 删除冗余的第三次恢复，避免数据被覆盖

---

## 问题与解决方案

### 问题1：软删除后分类仍然显示

#### 现象
点击删除分类，提示成功，但左侧分类列表中仍然显示该分类

#### 原因
`SaveCategoryDisplayConfig()` 只保存 `categories` 集合中的分类，而 `RefreshCategoryDisplay()` 已经过滤掉了 `IsHidden = true` 的分类，导致配置文件中没有保存隐藏状态

#### 解决方案
实现配置合并策略（方案A）：
1. 保存前先加载现有配置文件
2. 将当前可见分类的配置合并到现有配置中
3. 保存合并后的完整配置（包括已隐藏分类）

#### 代码位置
`MainWindow.xaml.cs` 第 10514-10575 行

---

### 问题2：RefreshCategoryDisplay 从内存加载配置

#### 现象
即使配置文件正确保存了 `IsHidden = true`，刷新后分类仍然显示

#### 原因
`RefreshCategoryDisplay()` 从 `categories` 集合中查找已存在分类，复制其配置：
```csharp
var existingCat = categories.FirstOrDefault(c => c.Name == cat.Name);
if (existingCat != null) {
    cat.IsHidden = existingCat.IsHidden;  // ❌ 隐藏分类不在集合中
}
```

`categories` 集合已过滤掉隐藏分类，所以新分类的 `IsHidden` 保持默认值 `false`

#### 解决方案
直接从配置文件加载，不依赖内存集合：
```csharp
var savedConfig = LoadFromConfigFile();
if (savedConfig.TryGetValue(cat.Name, out var config)) {
    cat.IsHidden = config.IsHidden;  // ✅ 从文件加载
}
```

#### 代码位置
`MainWindow.xaml.cs` 第 8108-8142 行

---

### 问题3：默认分类无法隐藏

#### 现象
自定义分类（如"1"、"2"）可以成功隐藏，但默认分类（面部、人物、武器等）删除后仍然显示

#### 原因
`RefreshCategoryDisplay()` 在更新 `categories` 集合后调用了 `InitializeDefaultCategories()`：
```csharp
Dispatcher.Invoke(() => {
    categories.Clear();
    foreach (var cat in visibleCategories) {
        categories.Add(cat);  // ✅ 正确过滤了隐藏分类
    }

    InitializeDefaultCategories();  // ❌ 重新添加默认分类，IsHidden = false
});
```

`InitializeDefaultCategories()` 检查默认分类是否存在，不存在则添加（`IsHidden` 默认为 `false`）：
```csharp
var defaultTypes = new[] { "面部", "人物", "武器", "服装", ... };
foreach (var type in defaultTypes) {
    if (!categories.Any(c => c.Name == type)) {
        categories.Add(new Category { Name = type, Count = count });
        // ❌ IsHidden 默认为 false
    }
}
```

#### 解决方案
删除 `RefreshCategoryDisplay()` 中的 `InitializeDefaultCategories()` 调用。默认分类已经在前面的逻辑中处理（从配置文件加载了 `IsHidden` 状态），不需要重复初始化。

#### 代码位置
`MainWindow.xaml.cs` 第 8187-8196 行（已删除该调用）

---

### 问题4：刷新后MOD分类被重置

#### 现象
1. 将MOD移动到自定义分类"2"
2. 点击刷新按钮
3. MOD回到原分类，自定义分类"2"消失

#### 原因
`RefreshButton_Click()` 中有三次数据恢复，且查询逻辑不一致：

**第一次（保存，第 4472-4476 行）：**
```csharp
var modInfo = _modService.Mods.FirstOrDefault(m =>
    m.Name == mod.RealName ||
    m.DisplayName == mod.Name ||  // ✅ 包含此条件
    (TryCompareImagePaths(...)));
```

**第二次（InitializeModsForGame 恢复）：**
正确恢复所有数据 ✅

**第三次（冗余恢复，第 4527-4530 行）：**
```csharp
var modInfo = _modService.Mods.FirstOrDefault(m =>
    m.Name == mod.RealName ||
    // ❌ 缺少 m.DisplayName == mod.Name 条件
    (TryCompareImagePaths(...)));

if (modInfo != null) {
    mod.Categories = modInfo.Categories?.ToList() ?? new List<string> { "未分类" };
    // ❌ 找不到modInfo时使用默认值，覆盖用户分类
}
```

**执行流程：**
1. 保存时能找到 `modInfo`（通过 `DisplayName` 匹配）
2. `InitializeModsForGame()` 正确恢复
3. 第三次恢复时找不到 `modInfo`（缺少 `DisplayName` 条件）
4. 使用 `new List<string> { "未分类" }` 覆盖用户分类

#### 解决方案
删除第三次恢复逻辑，依赖 `InitializeModsForGame()` 的统一恢复。

#### 代码位置
`MainWindow.xaml.cs` 第 4519-4545 行（已删除，替换为注释说明）

---

## 测试验证

### 测试环境
- **操作系统**：Windows 10/11
- **编译器**：Visual Studio 2022
- **.NET 版本**：.NET 8.0
- **游戏**：剑星、黑神话悟空、明末无双

### 测试用例

#### 测试1：重命名分类
**步骤：**
1. 右键点击分类"面部"
2. 选择"重命名分类"
3. 输入"面部MOD"
4. 确认

**预期结果：**
- 左侧分类列表显示"面部MOD"
- 右侧MOD标签仍显示"面部"
- 右键菜单显示"面部（面部MOD）"
- 配置文件中保存 `"面部": {"DisplayName": "面部MOD", "IsHidden": false}`

**验证点：**
- [ ] UI显示正确
- [ ] MOD标签未变
- [ ] 配置持久化
- [ ] 刷新后保持

---

#### 测试2：恢复默认名称
**步骤：**
1. 右键点击已重命名的分类"面部MOD"
2. 选择"重命名分类"
3. 输入"面部"（等于标签名）
4. 确认

**预期结果：**
- 左侧分类列表显示"面部"
- `DisplayName` 字段为 `null`
- 配置文件中移除该分类的配置项

**验证点：**
- [ ] UI恢复默认
- [ ] 配置文件更新

---

#### 测试3：删除空分类
**步骤：**
1. 创建新分类"测试分类"（无MOD）
2. 右键点击"测试分类"
3. 选择"删除分类"
4. 确认

**预期结果：**
- 分类从列表中消失
- 配置文件中 `"测试分类": {"DisplayName": null, "IsHidden": true}`
- 刷新后仍不显示

**验证点：**
- [ ] UI立即隐藏
- [ ] 配置持久化
- [ ] 刷新后仍隐藏

---

#### 测试4：删除有MOD的分类
**步骤：**
1. 创建分类"自定义分类"
2. 移动3个MOD到"自定义分类"
3. 右键点击"自定义分类"
4. 选择"删除分类"
5. 确认对话框（提示3个MOD将移动到未分类）

**预期结果：**
- 3个MOD移动到"未分类"
- MOD的 `Type` 和 `Categories` 字段更新
- 分类从列表中消失
- ModService配置文件更新

**验证点：**
- [ ] MOD成功移动
- [ ] MOD数据持久化
- [ ] 分类隐藏
- [ ] 刷新后MOD仍在未分类

---

#### 测试5：删除默认分类
**步骤：**
1. 右键点击默认分类"面部"
2. 选择"删除分类"
3. 确认

**预期结果：**
- 分类"面部"从列表中消失
- 配置文件中 `"面部": {"DisplayName": null, "IsHidden": true}`

**验证点：**
- [ ] 默认分类可以隐藏
- [ ] 刷新后仍隐藏

---

#### 测试6：智能显示隐藏分类
**步骤：**
1. 删除分类"武器"（设置 `IsHidden = true`）
2. 手动编辑MOD配置文件，添加 `"Categories": ["武器"]`
3. 刷新分类显示

**预期结果：**
- 分类"武器"自动显示在列表中
- 配置文件中仍保留 `"武器": {"IsHidden": true}`
- 控制台输出智能显示日志

**验证点：**
- [ ] 隐藏分类自动显示
- [ ] 配置未被修改

---

#### 测试7：刷新后分类配置保持
**步骤：**
1. 重命名分类"面部"为"面部MOD"
2. 删除分类"服装"
3. 点击刷新按钮
4. 检查分类列表

**预期结果：**
- "面部MOD"仍显示为"面部MOD"
- "服装"仍处于隐藏状态
- 配置未丢失

**验证点：**
- [ ] DisplayName保持
- [ ] IsHidden保持
- [ ] 从配置文件正确加载

---

#### 测试8：MOD分类刷新保持
**步骤：**
1. 创建新分类"自定义"
2. 移动MOD到"自定义"
3. 点击刷新按钮
4. 检查MOD所在分类

**预期结果：**
- MOD仍在"自定义"分类
- "自定义"分类仍然显示

**验证点：**
- [ ] MOD分类未被重置
- [ ] 自定义分类未消失

---

#### 测试9：多选批量删除
**步骤：**
1. Ctrl+点击选择多个分类
2. 右键选择"删除分类"
3. 确认

**预期结果：**
- 所有选中分类被隐藏
- 所有分类下的MOD移动到"未分类"

**验证点：**
- [ ] 批量隐藏成功
- [ ] MOD数据正确更新

---

#### 测试10：跨游戏配置隔离
**步骤：**
1. 在游戏A中重命名分类"面部"为"面部A"
2. 切换到游戏B
3. 检查分类"面部"的显示名称

**预期结果：**
- 游戏B的"面部"显示为默认名称（未受影响）
- 配置文件独立：`游戏A_category_display.json` 和 `游戏B_category_display.json`

**验证点：**
- [ ] 配置文件隔离
- [ ] 互不影响

---

### 性能测试

#### 测试11：大量分类性能
**步骤：**
1. 创建50个自定义分类
2. 重命名所有分类
3. 点击刷新
4. 记录耗时

**预期结果：**
- 刷新耗时 < 1秒
- UI不卡顿

---

#### 测试12：大量MOD分类移动
**步骤：**
1. 创建分类包含100个MOD
2. 删除该分类
3. 记录耗时

**预期结果：**
- MOD移动耗时 < 3秒
- 数据完整保存

---

### 回归测试

#### 测试13：原有功能未受影响
**验证点：**
- [ ] MOD安装/卸载正常
- [ ] MOD启用/禁用正常
- [ ] 拖拽排序正常（"全部"和"未分类"除外）
- [ ] 搜索过滤正常
- [ ] 备份恢复正常

---

## 注意事项

### 开发注意事项

#### 1. 数据一致性
- **Name 不可变**：`Category.Name` 是MOD关联的标签名，不要修改
- **DisplayName 可变**：只用于UI显示，可以随意修改
- **修改MOD标签**：如果需要修改MOD的标签，必须同步更新 `mod.Type` 和 `mod.Categories`，并调用 `SaveModsToModServiceAsync()`

#### 2. 配置文件操作
- **合并策略**：保存配置时必须先加载现有配置，再合并更新
- **UTF8编码**：读写配置文件必须使用 `System.Text.Encoding.UTF8`
- **路径独立**：每个游戏使用独立的配置文件

#### 3. ObservableCollection 同步
- **Dispatcher**：所有UI更新必须在UI线程执行（使用 `Dispatcher.Invoke`）
- **INotifyPropertyChanged**：`Category` 类必须实现该接口，确保数据绑定生效
- **OnPropertyChanged**：修改属性后必须调用 `OnPropertyChanged()`

#### 4. 查询逻辑一致性
- **保存和恢复**：查询 `modInfo` 的逻辑必须完全一致
- **三个条件**：`m.Name == mod.RealName || m.DisplayName == mod.Name || 图片对比`
- **不要遗漏**：特别是 `DisplayName` 条件，容易被遗漏

#### 5. 智能显示逻辑
- **自动显示**：如果隐藏分类有MOD使用，必须自动显示
- **临时取消**：`cat.IsHidden = false` 只是临时取消，不修改配置文件
- **下次刷新**：如果MOD不再使用该分类，下次刷新会重新隐藏

---

### 用户注意事项

#### 1. 重命名分类
- **只改显示**：重命名只修改左侧列表的显示名称
- **标签不变**：MOD区的标签名称不会改变
- **恢复默认**：输入标签名可恢复默认显示

#### 2. 删除分类
- **软删除**：删除实际上是隐藏，不是真删除
- **自动移动**：分类下的MOD会自动移动到"未分类"
- **智能显示**：如果MOD重新使用该分类，它会自动显示

#### 3. 配置文件位置
- **路径**：`%AppData%\UEModManager\{游戏名}_category_display.json`
- **手动编辑**：可以手动编辑JSON文件修改配置
- **备份建议**：建议定期备份配置文件

---

## 后续维护指南

### 代码维护

#### 1. 添加新游戏支持
**需要修改的地方：**
- 无需修改分类系统代码
- 配置文件会自动创建（根据 `_currentGame` 变量）

#### 2. 添加新的分类属性
**步骤：**
1. 在 `Category` 类中添加新属性
2. 在 `CategoryDisplayConfig` 类中添加对应字段
3. 修改 `SaveCategoryDisplayConfig()` 保存新字段
4. 修改 `RefreshCategoryDisplay()` 加载新字段
5. 如需UI显示，修改 `MainWindow.xaml`

**示例（添加颜色属性）：**
```csharp
// Category.cs
public class Category : INotifyPropertyChanged
{
    // ... 现有代码 ...

    private string? _color;
    public string? Color
    {
        get => _color;
        set
        {
            if (_color != value)
            {
                _color = value;
                OnPropertyChanged(nameof(Color));
            }
        }
    }
}

// CategoryDisplayConfig.cs
public class CategoryDisplayConfig
{
    public string? DisplayName { get; set; }
    public bool IsHidden { get; set; }
    public string? Color { get; set; }  // 新增
}

// SaveCategoryDisplayConfig
config[cat.Name] = new CategoryDisplayConfig
{
    DisplayName = cat.DisplayName,
    IsHidden = cat.IsHidden,
    Color = cat.Color  // 新增
};

// RefreshCategoryDisplay
cat.Color = config.Color;  // 新增
```

#### 3. 修改智能显示逻辑
**当前逻辑**：分类下有MOD（`Count > 0`）则自动显示

**修改位置**：`RefreshCategoryDisplay()` 第 8143-8148 行
```csharp
if (cat.IsHidden && cat.Count > 0)
{
    Console.WriteLine($"[智能显示] 分类 '{cat.Name}' 虽然已隐藏，但仍有 {cat.Count} 个MOD使用，自动显示");
    cat.IsHidden = false;  // 临时取消隐藏
}
```

**可能的修改**：
- 只对用户主动使用的分类自动显示（排除自动生成的）
- 添加用户设置：是否启用智能显示
- 添加延迟隐藏：分类空闲30天后才隐藏

#### 4. 优化性能
**当前瓶颈**：
- JSON文件读写（每次刷新都读取）
- 大量MOD移动时的数据库操作

**优化方案**：
- **缓存配置**：在内存中缓存配置，只在必要时读取文件
- **批量更新**：使用事务批量更新MOD数据
- **异步操作**：使用 `async/await` 避免UI阻塞

**示例（缓存配置）：**
```csharp
private Dictionary<string, CategoryDisplayConfig>? _cachedConfig;
private DateTime _configLoadTime;

private Dictionary<string, CategoryDisplayConfig> LoadCategoryDisplayConfig()
{
    // 如果缓存存在且不超过5分钟，直接返回
    if (_cachedConfig != null && (DateTime.Now - _configLoadTime).TotalMinutes < 5)
    {
        return _cachedConfig;
    }

    // 从文件加载
    var configPath = GetCategoryDisplayConfigPath();
    if (File.Exists(configPath))
    {
        var json = File.ReadAllText(configPath, System.Text.Encoding.UTF8);
        _cachedConfig = JsonSerializer.Deserialize<Dictionary<...>>(json);
        _configLoadTime = DateTime.Now;
    }

    return _cachedConfig ?? new Dictionary<...>();
}

private void InvalidateConfigCache()
{
    _cachedConfig = null;  // 修改后清除缓存
}
```

---

### 常见问题排查

#### 问题1：分类配置丢失
**症状**：重命名或删除的分类在重启后恢复原状

**排查步骤**：
1. 检查配置文件是否存在：`%AppData%\UEModManager\{游戏名}_category_display.json`
2. 检查文件内容是否正确
3. 检查控制台日志：搜索 `[保存]` 和 `[刷新]` 关键字
4. 检查是否有异常：搜索 `[错误]` 或 `[警告]`

**可能原因**：
- 文件权限问题（无法写入）
- JSON序列化失败（特殊字符）
- 游戏名称变量 `_currentGame` 不一致

---

#### 问题2：MOD分类被重置
**症状**：刷新后MOD回到默认分类

**排查步骤**：
1. 检查 `RefreshButton_Click` 是否有冗余恢复逻辑
2. 检查 `InitializeModsForGame` 的查询逻辑
3. 检查 ModService 配置文件是否正确保存
4. 检查控制台日志：搜索 `[DEBUG]`

**可能原因**：
- 查询逻辑不一致（保存和恢复）
- ModService 未保存
- 数据恢复顺序错误

---

#### 问题3：默认分类无法隐藏
**症状**：删除默认分类后仍显示

**排查步骤**：
1. 检查 `RefreshCategoryDisplay` 是否调用了 `InitializeDefaultCategories()`
2. 检查配置文件中 `IsHidden` 字段
3. 检查智能显示逻辑是否误触发

**可能原因**：
- `InitializeDefaultCategories()` 重新添加
- 配置未从文件加载（从内存加载）
- 分类下有MOD，智能显示逻辑自动显示

---

#### 问题4：UI不更新
**症状**：修改分类名称或删除后UI没有变化

**排查步骤**：
1. 检查 `Category` 是否实现 `INotifyPropertyChanged`
2. 检查是否调用 `OnPropertyChanged()`
3. 检查是否在UI线程更新（使用 `Dispatcher.Invoke`）
4. 检查是否调用 `RefreshCategoryDisplay()`

**可能原因**：
- 未触发属性变更通知
- 在后台线程修改UI
- 未刷新 `ObservableCollection`

---

### 版本兼容性

#### 配置文件迁移
**旧版本**：无配置文件，分类名称和MOD标签绑定

**新版本**：引入配置文件，支持DisplayName和IsHidden

**迁移策略**：
1. **自动兼容**：无配置文件时自动创建
2. **默认值**：`DisplayName = null`，`IsHidden = false`
3. **无需手动迁移**

**示例（配置文件不存在）：**
```csharp
// RefreshCategoryDisplay
var savedConfig = LoadConfigFromFile();  // 返回 null 或空字典

foreach (var cat in newCategories) {
    if (savedConfig != null && savedConfig.TryGetValue(cat.Name, out var config)) {
        cat.DisplayName = config.DisplayName;
        cat.IsHidden = config.IsHidden;
    } else {
        // 使用默认值（已在Category构造时初始化）
        // DisplayName = null, IsHidden = false
    }
}
```

---

### 扩展建议

#### 1. 分类图标
**需求**：允许用户为分类设置自定义图标

**实现**：
- 添加 `Category.IconPath` 属性
- 添加 `CategoryDisplayConfig.IconPath` 字段
- 修改 XAML 绑定图标
- 添加右键菜单"设置图标"

#### 2. 分类颜色
**需求**：允许用户为分类设置颜色标记

**实现**：
- 添加 `Category.Color` 属性
- 添加 `CategoryDisplayConfig.Color` 字段
- 修改 XAML 背景色绑定
- 添加颜色选择器

#### 3. 分类排序
**需求**：允许用户自定义分类顺序

**实现**：
- 添加 `Category.SortOrder` 属性
- 添加 `CategoryDisplayConfig.SortOrder` 字段
- 实现拖拽排序
- 按 `SortOrder` 排序而非字母序

#### 4. 导入/导出分类配置
**需求**：跨设备同步分类配置

**实现**：
- 添加"导出配置"按钮，保存JSON文件
- 添加"导入配置"按钮，加载JSON文件
- 支持选择性导入（合并或覆盖）

#### 5. 批量操作
**需求**：批量重命名、批量删除、批量移动

**实现**：
- 多选分类（Ctrl+点击）
- 右键菜单支持批量操作
- 确认对话框显示操作详情

---

## 总结

### 本次修改要点

1. **数据模型扩展**：`Category` 添加 `DisplayName` 和 `IsHidden` 属性
2. **配置持久化**：JSON文件存储分类配置
3. **配置合并策略**：避免丢失隐藏分类配置
4. **从文件加载**：不依赖内存集合
5. **移除重复初始化**：避免覆盖隐藏状态
6. **统一数据恢复**：移除冗余恢复逻辑

### 关键技术点

- **配置合并**：保存前加载现有配置
- **数据绑定**：`INotifyPropertyChanged` 和 `ObservableCollection`
- **计算属性**：`DisplayText => DisplayName ?? Name`
- **智能显示**：有MOD使用时自动显示隐藏分类
- **查询一致性**：保存和恢复使用相同查询条件

### 已修复的BUG

1. ✅ 软删除不生效（配置合并策略）
2. ✅ 刷新后配置丢失（从文件加载）
3. ✅ 默认分类无法隐藏（移除重复初始化）
4. ✅ MOD分类被重置（移除冗余恢复）

### 测试通过项

- ✅ 重命名分类（DisplayName独立）
- ✅ 删除分类（软删除+MOD移动）
- ✅ 刷新保持配置（持久化）
- ✅ 智能显示（自动显示有MOD的隐藏分类）
- ✅ 默认分类可操作（面部、人物、武器等）

---

**文档版本**：1.0
**最后更新**：2025-10-05
**维护人员**：下一任开发者
**技术支持**：查看本文档"后续维护指南"章节

**重要提醒**：
1. 修改代码前务必理解"数据流图"和"关键技术点"
2. 遇到问题先查看"常见问题排查"章节
3. 添加新功能参考"代码维护"章节
4. 所有涉及分类配置的修改都要考虑配置文件的读写

---

## 附录

### 附录A：配置文件格式

**文件路径**：`%AppData%\UEModManager\{游戏名}_category_display.json`

**完整示例**：
```json
{
  "面部": {
    "DisplayName": "面部MOD",
    "IsHidden": false
  },
  "人物": {
    "DisplayName": null,
    "IsHidden": false
  },
  "武器": {
    "DisplayName": "武器装备",
    "IsHidden": true
  },
  "服装": {
    "DisplayName": null,
    "IsHidden": true
  },
  "自定义1": {
    "DisplayName": "我的收藏",
    "IsHidden": false
  }
}
```

**字段说明**：
- **DisplayName**：自定义显示名称，`null` 表示使用默认名称
- **IsHidden**：是否隐藏，`true` 表示已删除（软删除）

---

### 附录B：相关代码位置索引

| 功能 | 文件 | 行号 | 说明 |
|-----|------|------|------|
| Category 数据模型 | MainWindow.xaml.cs | 10623-10691 | 分类数据模型定义 |
| CategoryDisplayConfig | MainWindow.xaml.cs | 10693-10697 | 配置文件数据模型 |
| GetCategoryDisplayConfigPath | MainWindow.xaml.cs | 10582-10590 | 获取配置文件路径 |
| SaveCategoryDisplayConfig | MainWindow.xaml.cs | 10514-10575 | 保存配置（合并策略） |
| RefreshCategoryDisplay | MainWindow.xaml.cs | 8071-8196 | 刷新分类显示 |
| - 从文件加载配置 | MainWindow.xaml.cs | 8108-8142 | 加载DisplayName和IsHidden |
| - 智能显示逻辑 | MainWindow.xaml.cs | 8143-8148 | 自动显示有MOD的隐藏分类 |
| - 移除重复初始化 | MainWindow.xaml.cs | 8187-8196 | 已删除InitializeDefaultCategories |
| RenameCategoryButton_Click | MainWindow.xaml.cs | 9670-9730 | 重命名分类 |
| DeleteCategoryButton_Click | MainWindow.xaml.cs | 8255-8382 | 软删除分类 |
| MoveToCategorySubMenuItem | MainWindow.xaml.cs | 9081-9116 | 移动MOD菜单显示格式 |
| RefreshButton_Click | MainWindow.xaml.cs | 4519-4525 | 移除冗余恢复逻辑 |
| UI绑定 | MainWindow.xaml | 168 | Text="{Binding DisplayText}" |

---

### 附录C：控制台日志关键字

调试时可搜索以下关键字：

| 关键字 | 说明 | 示例 |
|-------|------|------|
| `[保存]` | 保存分类配置 | `[保存] 分类显示配置已保存: 5 个分类` |
| `[刷新]` | 刷新分类显示 | `[刷新] 从配置文件加载: 5 个分类配置` |
| `[重命名]` | 重命名分类 | `[重命名] 设置分类 '面部' 的显示名称为 '面部MOD'` |
| `[删除]` | 删除分类 | `[删除] 分类 '武器' 已设置为隐藏` |
| `[智能显示]` | 智能显示隐藏分类 | `[智能显示] 分类 '武器' 虽然已隐藏，但仍有 3 个MOD使用` |
| `[DEBUG]` | 调试信息 | `[DEBUG] MOD数据已在 InitializeModsForGame 中从 ModService 完整恢复` |
| `[错误]` | 错误信息 | `[错误] 保存分类显示配置失败: ...` |
| `[警告]` | 警告信息 | `[警告] 加载分类配置失败: ...` |

---

### 附录D：Git Commit 历史

**相关提交记录**：
```
commit xxxx - feat: 实现分类软删除和MOD自动移动
commit xxxx - fix: 修复默认分类无法隐藏的问题
commit xxxx - fix: 修复刷新后MOD分类被重置的问题
commit xxxx - refactor: 移除RefreshButton_Click中的冗余数据恢复逻辑
```

---

**文档结束**

如有疑问，请参考代码注释或联系前任开发者。
